<!DOCTYPE html>
<html lang="en">
  <head>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
        }
    }
    </script>
    <meta charset="UTF-8" />
    <title>Ciallo</title>
    <style>
			body { margin: 0; }
		</style>
  </head>
  <body>
    <script id="vertexShader" type="x-shader/x-vertex">
      precision mediump float;
      precision mediump int;
      
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      
      in vec2 position0;
      in float radius0;
      in vec2 position1;
      in float radius1;
      
      out vec2 p;
      out float r;
      flat out vec2 p0;
      flat out float r0;
      flat out vec2 p1;
      flat out float r1;
      
      void main()	{
          r0 = radius0;
          r1 = radius1;
          p0 = position0;
          p1 = position1;
          vec2 tangentDirection = normalize(position1 - position0);
          vec2 normalDirection = vec2(-tangentDirection.y, tangentDirection.x);
          float cosTheta = (r0 - r1)/distance(p0, p1); // theta is the angle stroke tilt.
         
          vec2[] offsetSigns = vec2[](
              vec2(-1.0, -1.0),
              vec2(-1.0, 1.0), 
              vec2(1.0,  1.0),
              vec2(1.0,  -1.0));
          vec2 offsetSign = offsetSigns[gl_VertexID];
      
          vec2[] polylineVertexPositions = vec2[](position0, position0, position1, position1);
          vec2 pos = polylineVertexPositions[gl_VertexID];
          
          float radius = vec4(radius0, radius0, radius1, radius1)[gl_VertexID];
          r = radius;
      
          float tanHalfTheta = sqrt((1.0+cosTheta) / (1.0-cosTheta));
          float cotHalfTheta = 1.0 / tanHalfTheta;
          float normalTanValue = vec4(tanHalfTheta, tanHalfTheta, cotHalfTheta, cotHalfTheta)[gl_VertexID];
          vec2 trapzoidVertexPosition = pos + 
              offsetSign.x * radius * tangentDirection + 
              offsetSign.y * radius * normalDirection * normalTanValue;
          p = trapzoidVertexPosition;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(trapzoidVertexPosition, 0.0, 1.0);
      }
		</script>

    <script id="fragmentShader" type="x-shader/x-fragment">
      precision mediump float;
      precision mediump int;
      
      in vec2 p;
      in float r;
      flat in vec2 p0;
      flat in float r0;
      flat in vec2 p1;
      flat in float r1;
      
      uniform int type;
      const int Vanilla = 0, Stamp = 1, Airbrush = 2;
      uniform vec3 color;
      uniform float alpha;
      uniform mediump sampler2D tex;
      float sampleGraident(float distance){ return texture(tex, vec2(distance, 0.0)).r; }
      
      out vec4 outColor;
      
      void main()	{
          vec2 tangent = normalize(p1 - p0);
          vec2 normal = vec2(-tangent.y, tangent.x);
      
          float len = distance(p1, p0);
          vec2 pLocal = vec2(dot(p-p0, tangent), dot(p-p0, normal));
          vec2 p0Local = vec2(0, 0);
          vec2 p1Local = vec2(len, 0);
      
          float cosTheta = (r0 - r1)/len;
          float d0 = distance(p, p0);
          float d0cos = pLocal.x / d0;
          float d1 = distance(p, p1);
          float d1cos = (pLocal.x - len) / d1;
      
          // remove corners
          if(d0cos < cosTheta && d0 > r0) discard;
          if(d1cos > cosTheta && d1 > r1) discard;
          
          if(type == Vanilla){
              if(d0 < r0 && d1 < r1) discard;
              float A = (d0 < r0 || d1 < r1) ? 1.0 - sqrt(1.0 - alpha) : alpha;
              outColor = vec4(color, A);
          }
      
          if(type == Airbrush){
              float tanTheta = sqrt(1.0 - cosTheta*cosTheta)/cosTheta;
              float mid = pLocal.x - abs(pLocal.y)/tanTheta;
              float A = alpha;
              float transparency0 = d0 > r0 ? 1.0:sqrt(1.0 - A*sampleGraident(d0/r0));
              float transparency1 = d1 > r1 ? 1.0:sqrt(1.0 - A*sampleGraident(d1/r1));
              float transparency;
      
              if(mid <= 0.0){
                  transparency = transparency0/transparency1;
              }
              if(mid > 0.0 && mid < len){
                  float r = (mid * r1 + (len - mid) * r0)/len;
                  float dr = distance(pLocal, vec2(mid, 0))/r;
                  transparency = (1.0 - A*sampleGraident(dr))/transparency0/transparency1;
              }
              if(mid >= len){
                  transparency = transparency1/transparency0;
              }
      
              outColor = vec4(color, 1.0 - transparency);
          }
          return;
        }
		</script>

    <script type="module" src="./main.js"></script>
  </body>
</html>